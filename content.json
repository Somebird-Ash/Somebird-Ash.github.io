{"meta":{"title":"Somebird的林间小仓库","subtitle":"Recording for Remembering","description":"记录成长之路","author":"Somebird","url":"http://example.com","root":"/"},"pages":[{"title":"categories","date":"2024-12-25T14:24:22.000Z","updated":"2024-12-25T14:32:19.490Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2024-12-25T14:33:58.000Z","updated":"2024-12-25T14:35:29.868Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"2024NewStarCTF_WP_Web","slug":"2024NewStarCTF-WP-Web","date":"2024-12-28T15:18:43.000Z","updated":"2025-01-02T02:21:44.547Z","comments":true,"path":"2024/12/28/2024NewStarCTF-WP-Web/","permalink":"http://example.com/2024/12/28/2024NewStarCTF-WP-Web/","excerpt":"","text":"Week 2pangbai过家家(2) 连接进入，叫清点泄露文件 首先用dirsearch扫一下目录 发现.git文件，确定为git泄露，用Githack把泄露的文件下载下来 log和branch都没有找到后门，还有可能的就是stash(临时保存区)了 Git – Stash命令|极客教程 发现后面，用stash apply将暂存区重新应用 找到后门文件源代码，发现是一个正则表达式绕过 关键点1：非法字符转换下划线 故这里在提交payload时，NewStar_CTF.2024要写为NewStar[CTF.2024 关键点2：正则表达式首位检测绕过 preg_match默认为单行模式，如果字符串末尾是换行符，则换行符会被当做行尾而不是字符串的一部分，但是在严格不等于!&#x3D;&#x3D;中，”Welcome”和”Welcome\\n”是不等的， 所以这里构造的最终payload是 NewStar[CTF.2024&#x3D;Welcome%0a（%0a是换行符的url编码） func&#x3D;system args&#x3D;’ls &#x2F;‘ 传入发现没有回显，猜测是ls &#x2F;被过滤了或者缺少权限（？其实我也不知道为什么），因为之前的flag大部分都在环境变量里，所以这里尝试用env语句打印环境变量 得到flag 遗失的拉链题目是拉链，想到zip，应该是一个.zip源码泄露，所以先扫一下目录看看 果然有，下载下来，拿到源代码 有一个php内容如下 是一个简单的比较绕过 sha_1和md5强相等，这个应该是很难找到两个字符符合要求的，所以想到传入两个数组，这样两个函数的返回值都是null，就可以强相等了，同时也绕过了不等号 代码里把cat和flag过滤了，我们用和cat效果差不多的more来读取文件，flag也不用打全，用通配符*即可 week 3臭皮的计算器载入页面，叫我们去&#x2F;cal路径，来到这个路径后，查看源代码，发现后端flask源码直接给了 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from flask import Flask, render_template, requestimport uuidimport subprocessimport osimport tempfileapp = Flask(__name__)app.secret_key = str(uuid.uuid4())def waf(s): token = True for i in s: if i in &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;: token = False break return token@app.route(&quot;/&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/calc&quot;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def calc(): if request.method == &#x27;POST&#x27;: num = request.form.get(&quot;num&quot;) script = f&#x27;&#x27;&#x27;import osprint(eval(&quot;&#123;num&#125;&quot;))&#x27;&#x27;&#x27; print(script) if waf(num): try: result_output = &#x27;&#x27; with tempfile.NamedTemporaryFile(mode=&#x27;w+&#x27;, suffix=&#x27;.py&#x27;, delete=False) as temp_script: temp_script.write(script) temp_script_path = temp_script.name result = subprocess.run([&#x27;python3&#x27;, temp_script_path], capture_output=True, text=True) os.remove(temp_script_path) result_output = result.stdout if result.returncode == 0 else result.stderr except Exception as e: result_output = str(e) return render_template(&quot;calc.html&quot;, result=result_output) else: return render_template(&quot;calc.html&quot;, result=&quot;臭皮！你想干什么！！&quot;) return render_template(&quot;calc.html&quot;, result=&#x27;试试呗&#x27;)if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;, port=30002) 分析源码可得，我们输入num，程序自动计算num的表达式数值，且用到了eval函数，这里包含一个RCE漏洞，但关键在于，还有一个防火墙，过滤了所有字母，所以是一个无字母的RCE。 python的无字母rce，用的比较多的是八进制绕过，这里简单写一个程序把我们的payload转为八进制编码。 12345678txt=input(&quot;payload:&quot;)payload=&quot;&quot;for i in txt: if i.isalpha() or i==&#x27;_&#x27; : payload+=&#x27;\\\\&#x27;+oct(ord(i))[2:] else: payload+=iprint(payload) 传入得到flag","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"CTFwp","slug":"CTFwp","permalink":"http://example.com/tags/CTFwp/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"CTFwp","slug":"CTFwp","permalink":"http://example.com/tags/CTFwp/"}]}